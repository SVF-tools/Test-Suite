; ModuleID = '/home/runner/work/Test-Suite/Test-Suite/test_cases_bc/ae_bufoverflow_tests/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_01.c.bc'
source_filename = "/home/runner/work/Test-Suite/Test-Suite/src/ae_bufoverflow_tests/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_01.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct._charVoid = type { [16 x i32], ptr, ptr }

@.str = private unnamed_addr constant [32 x i32] [i32 48, i32 49, i32 50, i32 51, i32 52, i32 53, i32 54, i32 55, i32 56, i32 57, i32 97, i32 98, i32 99, i32 100, i32 101, i32 102, i32 48, i32 49, i32 50, i32 51, i32 52, i32 53, i32 54, i32 55, i32 56, i32 57, i32 97, i32 98, i32 99, i32 100, i32 101, i32 0], align 4

; Function Attrs: noinline nounwind optnone uwtable
define dso_local void @CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_01_bad() #0 {
entry:
  %structCharVoid = alloca ptr, align 8
  %call = call noalias ptr @malloc(i64 noundef 80) #5
  store ptr %call, ptr %structCharVoid, align 8
  %0 = load ptr, ptr %structCharVoid, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @exit(i32 noundef -1) #6
  unreachable

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %structCharVoid, align 8
  %voidSecond = getelementptr inbounds %struct._charVoid, ptr %1, i32 0, i32 1
  store ptr @.str, ptr %voidSecond, align 8
  %2 = load ptr, ptr %structCharVoid, align 8
  %voidSecond1 = getelementptr inbounds %struct._charVoid, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %voidSecond1, align 8
  call void @printWLine(ptr noundef %3)
  %4 = load ptr, ptr %structCharVoid, align 8
  %charFirst = getelementptr inbounds %struct._charVoid, ptr %4, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i32], ptr %charFirst, i64 0, i64 0
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %arraydecay, ptr align 4 @.str, i64 80, i1 false)
  %5 = load ptr, ptr %structCharVoid, align 8
  %charFirst2 = getelementptr inbounds %struct._charVoid, ptr %5, i32 0, i32 0
  %arraydecay3 = getelementptr inbounds [16 x i32], ptr %charFirst2, i64 0, i64 0
  %call4 = call i32 (ptr, i64, ...) @UNSAFE_BUFACCESS(ptr noundef %arraydecay3, i64 noundef 79)
  %call5 = call i32 (ptr, i64, ...) @SAFE_BUFACCESS(ptr noundef @.str, i64 noundef 79)
  %6 = load ptr, ptr %structCharVoid, align 8
  %charFirst6 = getelementptr inbounds %struct._charVoid, ptr %6, i32 0, i32 0
  %arrayidx = getelementptr inbounds [16 x i32], ptr %charFirst6, i64 0, i64 15
  store i32 0, ptr %arrayidx, align 4
  %7 = load ptr, ptr %structCharVoid, align 8
  %charFirst7 = getelementptr inbounds %struct._charVoid, ptr %7, i32 0, i32 0
  %arraydecay8 = getelementptr inbounds [16 x i32], ptr %charFirst7, i64 0, i64 0
  call void @printWLine(ptr noundef %arraydecay8)
  %8 = load ptr, ptr %structCharVoid, align 8
  %voidSecond9 = getelementptr inbounds %struct._charVoid, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %voidSecond9, align 8
  call void @printWLine(ptr noundef %9)
  ret void
}

; Function Attrs: nounwind allocsize(0)
declare noalias ptr @malloc(i64 noundef) #1

; Function Attrs: noreturn nounwind
declare void @exit(i32 noundef) #2

declare void @printWLine(ptr noundef) #3

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #4

declare i32 @UNSAFE_BUFACCESS(...) #3

declare i32 @SAFE_BUFACCESS(...) #3

; Function Attrs: noinline nounwind optnone uwtable
define dso_local void @CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_01_good() #0 {
entry:
  call void @good1()
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @good1() #0 {
entry:
  %structCharVoid = alloca ptr, align 8
  %call = call noalias ptr @malloc(i64 noundef 80) #5
  store ptr %call, ptr %structCharVoid, align 8
  %0 = load ptr, ptr %structCharVoid, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @exit(i32 noundef -1) #6
  unreachable

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %structCharVoid, align 8
  %voidSecond = getelementptr inbounds %struct._charVoid, ptr %1, i32 0, i32 1
  store ptr @.str, ptr %voidSecond, align 8
  %2 = load ptr, ptr %structCharVoid, align 8
  %voidSecond1 = getelementptr inbounds %struct._charVoid, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %voidSecond1, align 8
  call void @printWLine(ptr noundef %3)
  %4 = load ptr, ptr %structCharVoid, align 8
  %charFirst = getelementptr inbounds %struct._charVoid, ptr %4, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i32], ptr %charFirst, i64 0, i64 0
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %arraydecay, ptr align 4 @.str, i64 64, i1 false)
  %5 = load ptr, ptr %structCharVoid, align 8
  %charFirst2 = getelementptr inbounds %struct._charVoid, ptr %5, i32 0, i32 0
  %arraydecay3 = getelementptr inbounds [16 x i32], ptr %charFirst2, i64 0, i64 0
  %call4 = call i32 (ptr, i64, ...) @SAFE_BUFACCESS(ptr noundef %arraydecay3, i64 noundef 63)
  %call5 = call i32 (ptr, i64, ...) @SAFE_BUFACCESS(ptr noundef @.str, i64 noundef 63)
  %6 = load ptr, ptr %structCharVoid, align 8
  %charFirst6 = getelementptr inbounds %struct._charVoid, ptr %6, i32 0, i32 0
  %arrayidx = getelementptr inbounds [16 x i32], ptr %charFirst6, i64 0, i64 15
  store i32 0, ptr %arrayidx, align 4
  %7 = load ptr, ptr %structCharVoid, align 8
  %charFirst7 = getelementptr inbounds %struct._charVoid, ptr %7, i32 0, i32 0
  %arraydecay8 = getelementptr inbounds [16 x i32], ptr %charFirst7, i64 0, i64 0
  call void @printWLine(ptr noundef %arraydecay8)
  %8 = load ptr, ptr %structCharVoid, align 8
  %voidSecond9 = getelementptr inbounds %struct._charVoid, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %voidSecond9, align 8
  call void @printWLine(ptr noundef %9)
  ret void
}

attributes #0 = { noinline nounwind optnone uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nounwind allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { nounwind allocsize(0) }
attributes #6 = { noreturn nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{!"clang version 16.0.0"}
